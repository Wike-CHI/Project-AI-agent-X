# 主动智能与情感计算技术预研

## 1. 情绪识别技术方案

### 1.1 方案 A：基于 LLM 的情感分析（推荐）

```python
# backend/src/pdns/emotion/recognizer.py

from enum import Enum
from pydantic import BaseModel
from typing import Optional
from json import loads as json_loads

class EmotionType(str, Enum):
    """情绪类型枚举"""
    JOY = "joy"           # 开心
    SADNESS = "sadness"   # 悲伤
    ANGER = "anger"       # 愤怒
    FEAR = "fear"         # 恐惧
    SURPRISE = "surprise" # 惊喜
    NEUTRAL = "neutral"   # 平静
    ANXIETY = "anxiety"   # 焦虑
    CALM = "calm"         # 平静

class EmotionResult(BaseModel):
    """情绪识别结果"""
    emotion: EmotionType
    confidence: float       # 置信度 (0-1)
    intensity: float        # 强度 (0-1)
    explanation: Optional[str] = None

class EmotionRecognizer:
    """基于 LLM 的情绪识别"""

    SYSTEM_PROMPT = """
    你是一个专业的情感分析助手。你的任务是分析用户消息中的情绪。

    可选情绪标签：
    - joy (开心): 用户表达积极、高兴的情绪
    - sadness (悲伤): 用户表达难过、伤心的情绪
    - anger (愤怒): 用户表达生气、不满的情绪
    - fear (恐惧): 用户表达担忧、害怕的情绪
    - surprise (惊喜): 用户表达惊讶、意外的情绪
    - neutral (平静): 用户表达中性、无明显情绪
    - anxiety (焦虑): 用户表达焦虑、紧张、不安
    - calm (平静): 用户表达平和、放松的状态

    分析要求：
    1. 仔细分析用户用词、语气和上下文
    2. 评估情绪强度 (0-1)，1表示非常强烈
    3. 给出置信度评分
    4. 如果有多个情绪，以主要情绪为准

    返回格式（JSON）：
    {
        "emotion": "标签",
        "confidence": 0.x,
        "intensity": 0.x,
        "explanation": "简短解释"
    }
    """

    def __init__(self, llm_gateway):
        self.llm = llm_gateway

    async def recognize(self, message: str, context: str = None) -> EmotionResult:
        """识别消息中的情绪"""
        prompt = f"{self.SYSTEM_PROMPT}\n\n用户消息：{message}"

        if context:
            prompt += f"\n\n对话上下文：{context}"

        result = await self.llm.generate(prompt, temperature=0.3)

        try:
            data = json_loads(result)
            return EmotionResult(
                emotion=EmotionType(data["emotion"]),
                confidence=data["confidence"],
                intensity=data["intensity"],
                explanation=data.get("explanation")
            )
        except (json.JSONDecodeError, KeyError, ValueError):
            # 解析失败，返回中性结果
            return EmotionResult(
                emotion=EmotionType.NEUTRAL,
                confidence=0.5,
                intensity=0.0,
                explanation="情绪解析失败，使用默认值"
            )

    async def recognize_batch(
        self,
        messages: list[str]
    ) -> list[EmotionResult]:
        """批量识别情绪"""
        results = []
        for message in messages:
            result = await self.recognize(message)
            results.append(result)
        return results
```

### 1.2 方案 B：本地轻量模型（备选）

```python
# backend/src/pdns/emotion/local_recognizer.py

from typing import Optional
import numpy as np

class LocalEmotionRecognizer:
    """本地轻量模型情绪识别（备选方案）"""

    # Hugging Face 轻量模型
    EMOTION_MODEL = "bhadresh-savani/distilbert-base-uncased-emotion"

    def __init__(self, model_path: str = None):
        try:
            from transformers import pipeline
            self.classifier = pipeline(
                "text-classification",
                model=self.EMOTION_MODEL,
                top_k=None,
                device=-1  # CPU
            )
            self.model_available = True
        except ImportError:
            self.model_available = False
            print("Warning: transformers not installed, using rule-based fallback")

    async def recognize(self, message: str) -> dict:
        """识别情绪"""
        if not self.model_available:
            return self._rule_based_recognize(message)

        results = self.classifier(message)[0]

        # 映射标签到统一枚举
        label_map = {
            "joy": "joy",
            "sadness": "sadness",
            "anger": "anger",
            "fear": "fear",
            "surprise": "surprise",
            "love": "joy",
            "neutral": "neutral"
        }

        # 返回最高置信度的结果
        top_result = results[0]
        return {
            "emotion": label_map.get(top_result["label"], "neutral"),
            "confidence": top_result["score"],
            "all_scores": {
                label_map.get(r["label"], r["label"]): r["score"]
                for r in results
            }
        }

    def _rule_based_recognize(self, message: str) -> dict:
        """基于规则的回退识别"""
        message_lower = message.lower()

        # 情绪关键词
        emotion_keywords = {
            "joy": ["开心", "高兴", "快乐", "太好了", "棒", "nice", "happy"],
            "sadness": ["难过", "伤心", "悲伤", "郁闷", "失落", "sad"],
            "anger": ["生气", "愤怒", "讨厌", "烦死了", "angry"],
            "fear": ["担心", "害怕", "恐惧", "焦虑", "worry", "afraid"],
            "anxiety": ["焦虑", "紧张", "不安", "心慌", "anxious"],
            "surprise": ["惊讶", "意外", "惊喜", " surprising"]
        }

        scores = {}
        for emotion, keywords in emotion_keywords.items():
            score = sum(1 for kw in keywords if kw in message_lower)
            scores[emotion] = score / len(keywords)

        if max(scores.values()) == 0:
            return {"emotion": "neutral", "confidence": 0.5}

        top_emotion = max(scores, key=scores.get)
        return {
            "emotion": top_emotion,
            "confidence": scores[top_emotion],
            "all_scores": scores
        }
```

## 2. 主动智能触发机制

```python
# backend/src/pdns/proactive/engine.py

from enum import Enum
from pydantic import BaseModel
from datetime import datetime, timedelta
from typing import Optional, List
from dataclasses import dataclass

class TriggerType(str, Enum):
    """触发器类型"""
    TIME_BASED = "time_based"       # 时间触发
    CONTEXT_BASED = "context_based" # 上下文触发
    BEHAVIOR_BASED = "behavior_based" # 行为模式触发

class Priority(str, Enum):
    """优先级"""
    LOW = "low"
    NORMAL = "normal"
    HIGH = "high"
    URGENT = "urgent"

class ProactiveAction(BaseModel):
    """主动智能动作"""
    type: str                       # 动作类型
    priority: Priority = Priority.NORMAL
    content: str                    # 动作内容
    triggered_by: TriggerType
    metadata: dict = {}

class ProactiveEngine:
    """主动智能引擎"""

    def __init__(
        self,
        memory_manager,
        emotion_recognizer,
        llm_gateway
    ):
        self.memory = memory_manager
        self.emotion = emotion_recognizer
        self.llm = llm_gateway
        self._trigger_last_check = {}

    TRIGGER_CONFIG = {
        "time_based": {
            "check_interval": 60,  # 秒
            "conditions": ["morning_reminder", "evening_summary"]
        },
        "context_based": {
            "conditions": ["schedule_conflict", "emotional_support"]
        },
        "behavior_based": {
            "conditions": ["pattern_detection", "habit_reminder"]
        }
    }

    async def evaluate_context(self, user_id: str) -> List[ProactiveAction]:
        """评估用户上下文，返回可能的主动动作"""
        actions = []

        # 1. 时间触发检查
        time_actions = await self._check_time_triggers(user_id)
        actions.extend(time_actions)

        # 2. 上下文触发检查
        context_actions = await self._check_context_triggers(user_id)
        actions.extend(context_actions)

        # 3. 行为模式触发检查
        behavior_actions = await self._check_behavior_triggers(user_id)
        actions.extend(behavior_actions)

        # 4. 按优先级排序
        priority_order = {"urgent": 0, "high": 1, "normal": 2, "low": 3}
        actions.sort(key=lambda x: priority_order[x.priority])

        return actions

    async def _check_time_triggers(self, user_id: str) -> List[ProactiveAction]:
        """检查时间触发器"""
        actions = []
        now = datetime.now()
        hour = now.hour

        # 检查是否需要冷却
        last_check = self._trigger_last_check.get("time_based")
        if last_check and (now - last_check).seconds < 60:
            return []

        self._trigger_last_check["time_based"] = now

        user_profile = await self.memory.get_user_profile(user_id)
        user_settings = user_profile.get("settings", {})

        # 早上问候 (7-9点)
        if 7 <= hour <= 9 and user_settings.get("morning_reminder", True):
            last_morning = await self.memory.get_last_interaction(user_id, "morning_greeting")
            if not last_morning or (now - last_morning).days >= 1:
                actions.append(ProactiveAction(
                    type="morning_greeting",
                    priority=Priority.LOW,
                    content="早上好！今天有什么计划吗？",
                    triggered_by=TriggerType.TIME_BASED
                ))

        # 晚上总结 (21-23点)
        if 21 <= hour <= 23 and user_settings.get("evening_summary", True):
            last_evening = await self.memory.get_last_interaction(user_id, "evening_summary")
            if not last_evening or (now - last_evening).days >= 1:
                actions.append(ProactiveAction(
                    type="evening_summary",
                    priority=Priority.LOW,
                    content="今天过得怎么样？有什么想分享的吗？",
                    triggered_by=TriggerType.TIME_BASED
                ))

        return actions

    async def _check_context_triggers(self, user_id: str) -> List[ProactiveAction]:
        """检查上下文触发器"""
        actions = []

        # 获取用户上下文
        context = await self.memory.get_context(user_id)
        recent_emotions = context.get("recent_emotions", [])

        # 检测情绪困扰
        if self._detect_emotional_distress(recent_emotions):
            actions.append(ProactiveAction(
                type="emotional_support",
                priority=Priority.URGENT,
                content="我注意到你今天情绪不太好，有什么想聊聊的吗？",
                triggered_by=TriggerType.CONTEXT_BASED,
                metadata={"emotions": recent_emotions}
            ))

        # 检测日程冲突
        if self._detect_schedule_conflict(context):
            actions.append(ProactiveAction(
                type="schedule_suggestion",
                priority=Priority.HIGH,
                content="检测到日程冲突，建议调整...",
                triggered_by=TriggerType.CONTEXT_BASED
            ))

        return actions

    async def _check_behavior_triggers(self, user_id: str) -> List[ProactiveAction]:
        """检查行为模式触发器"""
        actions = []

        # 获取用户行为模式
        patterns = await self.memory.get_behavior_patterns(user_id)

        # 检测异常行为模式
        if self._detect_anomaly(patterns):
            actions.append(ProactiveAction(
                type="behavior_checkin",
                priority=Priority.NORMAL,
                content="我注意到你今天有些不一样，一切都还好吗？",
                triggered_by=TriggerType.BEHAVIOR_BASED
            ))

        # 习惯提醒
        habits = await self.memory.get_habits(user_id)
        for habit in habits:
            if self._should_remind_habit(habit):
                actions.append(ProactiveAction(
                    type="habit_reminder",
                    priority=Priority.LOW,
                    content=f"别忘了：{habit.description}",
                    triggered_by=TriggerType.BEHAVIOR_BASED,
                    metadata={"habit_id": habit.id}
                ))

        return actions

    def _detect_emotional_distress(self, emotions: List[dict]) -> bool:
        """检测情绪困扰"""
        negative_emotions = {"sadness", "anger", "fear", "anxiety"}
        recent_distress = [
            e for e in emotions
            if e.get("emotion") in negative_emotions and e.get("intensity", 0) > 0.6
        ]
        return len(recent_distress) >= 2

    def _detect_schedule_conflict(self, context: dict) -> bool:
        """检测日程冲突"""
        schedule = context.get("schedule", [])
        conflicts = []
        for i, event1 in enumerate(schedule):
            for event2 in schedule[i+1:]:
                if self._events_overlap(event1, event2):
                    conflicts.append((event1, event2))
        return len(conflicts) > 0

    def _events_overlap(self, event1: dict, event2: dict) -> bool:
        """检查两个事件是否时间重叠"""
        start1, end1 = event1.get("start"), event1.get("end")
        start2, end2 = event2.get("start"), event2.get("end")
        return start1 < end2 and start2 < end1

    def _detect_anomaly(self, patterns: dict) -> bool:
        """检测行为异常"""
        # 简化的异常检测
        if not patterns:
            return False
        return patterns.get("anomaly_score", 0) > 0.7

    def _should_remind_habit(self, habit) -> bool:
        """检查是否应该提醒习惯"""
        # 简化的习惯提醒逻辑
        return not habit.completed_today
```

## 3. 情感记忆管理

```python
# backend/src/pdns/emotion/memory.py

from datetime import datetime
from typing import List, Optional
from pydantic import BaseModel

class EmotionalState(BaseModel):
    """情感状态"""
    dominant_emotion: str
    intensity: float
    timestamp: datetime
    context: str
    trigger_events: List[str] = []

class EmotionalMemory:
    """情感记忆管理"""

    def __init__(self, memory_manager):
        self.memory = memory_manager

    async def record_emotional_state(
        self,
        user_id: str,
        emotion: str,
        intensity: float,
        context: str,
        trigger_events: List[str] = None
    ):
        """记录情感状态"""
        state = EmotionalState(
            dominant_emotion=emotion,
            intensity=intensity,
            timestamp=datetime.utcnow(),
            context=context,
            trigger_events=trigger_events or []
        )

        # 保存到长期记忆
        await self.memory.add_memory(
            content=f"用户情绪: {emotion} (强度: {intensity:.2f})\n上下文: {context}",
            memory_type="emotional",
            importance=intensity,  # 高强度情绪更重要
            metadata={
                "user_id": user_id,
                "emotion_type": emotion,
                "intensity": intensity,
                "trigger_events": trigger_events
            }
        )

    async def get_emotional_patterns(
        self,
        user_id: str,
        days: int = 7
    ) -> dict:
        """获取情感模式分析"""
        memories = await self.memory.search(
            query="用户情绪情感",
            filters={"user_id": user_id},
            limit=100
        )

        # 简化分析
        emotion_counts = {}
        avg_intensity = 0

        for m in memories:
            emotion = m.metadata.get("emotion_type", "unknown")
            intensity = m.metadata.get("intensity", 0)
            emotion_counts[emotion] = emotion_counts.get(emotion, 0) + 1
            avg_intensity += intensity

        if memories:
            avg_intensity /= len(memories)

        return {
            "emotion_distribution": emotion_counts,
            "average_intensity": avg_intensity,
            "dominant_emotion": max(emotion_counts, key=emotion_counts.get) if emotion_counts else None,
            "analysis_period_days": days
        }

    async def get_emotional_context(
        self,
        user_id: str,
        current_emotion: str
    ) -> str:
        """获取情感上下文用于生成响应"""
        patterns = await self.get_emotional_patterns(user_id)

        # 根据当前情绪构建上下文提示
        context_parts = []

        if patterns["dominant_emotion"] == current_emotion:
            context_parts.append(f"用户最近经常表现出{current_emotion}情绪")

        # 添加历史情感信息
        for emotion, count in patterns["emotion_distribution"].items():
            if emotion != current_emotion and count > 3:
                context_parts.append(f"用户有时也会感到{emotion}")

        return " ".join(context_parts) if context_parts else ""
```

## 4. 技术风险与缓解

| 风险 | 概率 | 影响 | 缓解措施 |
|-----|-----|------|---------|
| LLM 情绪识别幻觉 | 中 | 中 | 本地模型兜底，多模型投票 |
| 主动介入频率过高 | 高 | 中 | 严格控制触发条件，用户可设置频率 |
| 隐私感知侵入 | 中 | 高 | 提供"勿扰模式"，透明化展示触发原因 |
| 情绪误判导致不当回应 | 中 | 高 | 设置安全阈值，敏感情绪转人工 |
| 行为模式误报 | 中 | 中 | 多维度验证，减少误报 |

## 5. 用户可控设置

```python
# 用户主动智能设置模型

class ProactiveSettings(BaseModel):
    """用户主动智能设置"""
    enabled: bool = True

    # 时间触发
    morning_reminder: bool = True
    morning_reminder_time: str = "08:00"
    evening_summary: bool = True
    evening_summary_time: str = "21:00"

    # 情感触发
    emotional_support: bool = True
    emotional_support_threshold: float = 0.7  # 强度阈值

    # 行为触发
    habit_reminders: bool = True
    behavior_anomaly_detection: bool = True

    # 勿扰模式
    do_not_disturb: bool = False
    do_not_disturb_start: str = "23:00"
    do_not_disturb_end: str = "07:00"

    # 主动介入频率限制
    max_actions_per_day: int = 10
    min_interval_minutes: int = 30

    def should_allow_action(self, action_type: str, current_time: datetime) -> bool:
        """检查是否允许执行主动动作"""
        if not self.enabled:
            return False

        if self.do_not_disturb:
            if self._in_time_range(
                current_time,
                self.do_not_disturb_start,
                self.do_not_disturb_end
            ):
                return False

        return True

    def _in_time_range(
        self,
        current: datetime,
        start: str,
        end: str
    ) -> bool:
        """检查当前时间是否在范围内（处理跨午夜情况）"""
        current_minutes = current.hour * 60 + current.minute
        start_minutes = int(start.split(":")[0]) * 60 + int(start.split(":")[1])
        end_minutes = int(end.split(":")[0]) * 60 + int(end.split(":")[1])

        if start_minutes <= end_minutes:
            return start_minutes <= current_minutes <= end_minutes
        else:
            return current_minutes >= start_minutes or current_minutes <= end_minutes
```

## 6. 文件结构

```
backend/src/pdns/
├── emotion/
│   ├── __init__.py
│   ├── recognizer.py         # 情绪识别器
│   ├── local_recognizer.py   # 本地模型回退
│   ├── memory.py             # 情感记忆管理
│   └── models.py             # 情感数据模型
│
└── proactive/
    ├── __init__.py
    ├── engine.py             # 主动智能引擎
    ├── triggers/             # 触发器模块
    │   ├── __init__.py
    │   ├── time_trigger.py
    │   ├── context_trigger.py
    │   └── behavior_trigger.py
    └── models.py             # 主动智能模型
```
