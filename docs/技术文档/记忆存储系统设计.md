# 记忆存储系统设计文档

## 1. 系统概述

本项目采用多层次记忆存储架构，结合向量数据库、图数据库和关系数据库，实现长期记忆、情景记忆和语义记忆的存储与检索。

```
┌─────────────────────────────────────────────────────────────────┐
│                       记忆存储架构                                │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│   ┌─────────────────────────────────────────────────────────┐   │
│   │                    应用层 (API/Agents)                   │   │
│   └─────────────────────────────────────────────────────────┘   │
│                              │                                   │
│              ┌───────────────┼───────────────┐                  │
│              ▼               ▼               ▼                  │
│   ┌──────────────────┐ ┌──────────────┐ ┌──────────────────┐   │
│   │  短期记忆         │ │ 情景记忆     │ │  语义记忆        │   │
│   │  (CrewAI Memory) │ │ (Neo4j)     │ │  (Qdrant)        │   │
│   └──────────────────┘ └──────────────┘ └──────────────────┘   │
│              │               │               │                  │
│              └───────────────┼───────────────┘                  │
│                              ▼                                   │
│                 ┌─────────────────────┐                         │
│                 │   关系数据库         │                         │
│                 │   (SQLite/PostgreSQL)│                        │
│                 └─────────────────────┘                         │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

## 2. 记忆类型定义

### 2.1 记忆分类

| 记忆类型 | 存储方式 | 特点 | 保留时间 |
|---------|---------|------|---------|
| **短期记忆** | CrewAI 内置 Memory | 当前对话上下文 | 会话期间 |
| **情景记忆** | Neo4j 图数据库 | 用户交互历史、事件关联 | 长期 |
| **语义记忆** | Qdrant 向量数据库 | 知识、概念、事实 | 长期 |
| **关系记忆** | SQLite/PostgreSQL | 用户偏好、配置信息 | 长期 |

### 2.2 记忆结构

```python
from pydantic import BaseModel
from datetime import datetime
from enum import Enum
from typing import Optional, List
from uuid import UUID, uuid4

class MemoryType(str, Enum):
    """记忆类型枚举"""
    EPISODIC = "episodic"       # 情景记忆
    SEMANTIC = "semantic"       # 语义记忆
    PROCEDURAL = "procedural"   # 程序性记忆
    EMOTIONAL = "emotional"     # 情感记忆
    RELATIONAL = "relational"   # 关系记忆

class Memory(BaseModel):
    """记忆基础模型"""
    id: UUID = Field(default_factory=uuid4)
    content: str                       # 记忆内容
    memory_type: MemoryType            # 记忆类型
    embedding: Optional[List[float]]   # 向量嵌入
    importance: float = 0.5            # 重要性评分 (0-1)
    emotional_valence: float = 0.0     # 情感极性 (-1 到 1)
    created_at: datetime = Field(default_factory=datetime.utcnow)
    last_accessed: datetime = Field(default_factory=datetime.utcnow)
    access_count: int = 0
    tags: List[str] = []
    metadata: dict = {}

class EpisodicMemory(Memory):
    """情景记忆 - 记录具体事件和经历"""
    event_type: str                    # 事件类型
    participants: List[str] = []       # 参与者
    location: Optional[str] = None     # 地点
    duration_seconds: Optional[int] = None  # 持续时间
    outcome: Optional[str] = None      # 结果
    emotional_context: dict = {}       # 情感上下文

class SemanticMemory(Memory):
    """语义记忆 - 存储知识和概念"""
    concept: str                       # 概念名称
    category: str                      # 类别
    definition: str                    # 定义
    related_concepts: List[str] = []   # 相关概念
    sources: List[str] = []            # 信息来源

class EmotionalMemory(Memory):
    """情感记忆 - 记录情感相关体验"""
    emotion_type: str                  # 情感类型
    intensity: float                   # 强度 (0-1)
    trigger: str                       # 触发因素
    response: str                      # 回应方式
    relationship_id: Optional[str] = None  # 关联关系
```

## 3. 向量数据库集成 (Qdrant)

### 3.1 配置

```python
# backend/src/pdns/memory/vector_store.py

from qdrant_client import QdrantClient
from qdrant_client.models import VectorParams, Distance

class VectorStore:
    """向量存储管理器 - Qdrant"""

    def __init__(self, config: Settings):
        self.client = QdrantClient(
            host=config.qdrant_host,
            port=config.qdrant_port,
            api_key=config.qdrant_api_key,
            path=config.qdrant_local_path  # 本地模式
        )
        self.collection_name = config.qdrant_collection_name
        self._ensure_collection()

    def _ensure_collection(self):
        """确保集合存在"""
        if not self.client.collection_exists(self.collection_name):
            self.client.create_collection(
                collection_name=self.collection_name,
                vectors_config=VectorParams(
                    size=384,  # 嵌入维度 (匹配 all-MiniLM-L6-v2)
                    distance=Distance.COSINE
                )
            )
```

### 3.2 语义记忆存储

```python
class SemanticMemoryStore(VectorStore):
    """语义记忆向量存储"""

    async def add_knowledge(
        self,
        concept: str,
        definition: str,
        category: str,
        embedding: List[float]
    ):
        """添加知识概念"""
        point = PointStruct(
            id=str(uuid4()),
            vector=embedding,
            payload={
                "type": "semantic",
                "concept": concept,
                "definition": definition,
                "category": category
            }
        )
        self.client.upsert(
            collection_name=self.collection_name,
            points=[point]
        )

    async def search_knowledge(
        self,
        query: str,
        query_embedding: List[float],
        limit: int = 5
    ) -> List[SearchResult]:
        """搜索知识"""
        return self.client.search(
            collection_name=self.collection_name,
            query_vector=query_embedding,
            query_filter=Filter(
                must=[FieldCondition(key="type", match=ValueMatcher(value="semantic"))]
            ),
            limit=limit
        )
```

## 4. 图数据库集成 (Neo4j)

### 4.1 连接配置

```python
# backend/src/pdns/memory/graph_store.py

from neo4j import GraphDatabase

class GraphStore:
    """图存储管理器 - Neo4j"""

    def __init__(self, config: Settings):
        self.driver = GraphDatabase.driver(
            config.neo4j_uri,
            auth=(config.neo4j_user, config.neo4j_password)
        )
        self.database = config.neo4j_database
```

### 4.2 情景记忆存储

```python
class EpisodicMemoryStore(GraphStore):
    """情景记忆图存储"""

    async def record_event(
        self,
        event_type: str,
        description: str,
        participants: List[str],
        location: Optional[str],
        emotional_context: dict
    ):
        """记录事件到图数据库"""
        with self.driver.session() as session:
            session.execute_write(self._create_event, ...)

    def _create_event(self, tx, event_data):
        """创建事件节点和关系"""
        query = """
        MERGE (e:Event {id: $id})
        SET e.type = $type,
            e.description = $description,
            e.location = $location,
            e.timestamp = datetime(),
            e.emotional_context = $emotional_context

        WITH e
        UNWIND $participants AS participant
        MERGE (p:Person {name: participant})
        MERGE (p)-[:PARTICIPATED_IN]->(e)

        RETURN e
        """
        return tx.run(query, event_data)
```

### 4.3 关系查询

```python
    async def get_relationship_history(
        self,
        person_a: str,
        person_b: str
    ) -> List[dict]:
        """获取两人之间的交互历史"""
        query = """
        MATCH (a:Person {name: $person_a})-[r:INTERACTED_WITH]->(b:Person {name: $person_b})
        MATCH (e:Event)-[:PARTICIPATED_IN]->(a)
        MATCH (e)-[:PARTICIPATED_IN]->(b)
        RETURN e, r, collect(e) as events
        ORDER BY e.timestamp DESC
        """
        # 执行查询并返回结果
```

## 5. 关系数据库 (SQLite)

### 5.1 用户配置存储

```python
# backend/src/pdns/memory/relational_store.py

import sqlite3
from pathlib import Path

class RelationalStore:
    """关系数据库存储 - SQLite"""

    def __init__(self, db_path: Path):
        self.db_path = db_path
        self._init_db()

    def _init_db(self):
        """初始化数据库表"""
        with sqlite3.connect(self.db_path) as conn:
            conn.executescript("""
                CREATE TABLE IF NOT EXISTS users (
                    id TEXT PRIMARY KEY,
                    name TEXT NOT NULL,
                    preferences TEXT,
                    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
                );

                CREATE TABLE IF NOT EXISTS user_preferences (
                    user_id TEXT,
                    key TEXT,
                    value TEXT,
                    PRIMARY KEY (user_id, key),
                    FOREIGN KEY (user_id) REFERENCES users(id)
                );

                CREATE TABLE IF NOT EXISTS agent_config (
                    id TEXT PRIMARY KEY,
                    user_id TEXT,
                    agent_type TEXT,
                    config TEXT,
                    FOREIGN KEY (user_id) REFERENCES users(id)
                );
            """)
```

## 6. 统一记忆接口

### 6.1 MemoryManager

```python
# backend/src/pdns/memory/manager.py

class MemoryManager:
    """统一记忆管理器"""

    def __init__(
        self,
        vector_store: VectorStore,
        graph_store: GraphStore,
        relational_store: RelationalStore,
        embedding_service: EmbeddingService
    ):
        self.vector = vector_store
        self.graph = graph_store
        self.relational = relational_store
        self.embedding = embedding_service

    async def add_memory(
        self,
        content: str,
        memory_type: MemoryType,
        importance: float = 0.5,
        metadata: dict = None,
        **kwargs
    ) -> Memory:
        """添加记忆 - 根据类型分发到对应存储"""

        # 生成向量嵌入
        embedding = await self.embedding.embed(content)

        # 创建记忆对象
        memory = Memory(
            content=content,
            memory_type=memory_type,
            embedding=embedding,
            importance=importance,
            metadata=metadata or {},
            **kwargs
        )

        # 根据类型分发存储
        if memory_type == MemoryType.SEMANTIC:
            await self._store_semantic(memory)
        elif memory_type == MemoryType.EPISODIC:
            await self._store_episodic(memory)
        elif memory_type == MemoryType.EMOTIONAL:
            await self._store_emotional(memory)
        elif memory_type == MemoryType.RELATIONAL:
            await self._store_relational(memory)

        return memory

    async def recall(
        self,
        query: str,
        memory_types: List[MemoryType] = None,
        limit: int = 10
    ) -> List[RecallResult]:
        """回忆 - 跨存储检索"""

        # 生成查询向量
        query_embedding = await self.embedding.embed(query)

        results = []

        # 并行检索各类型记忆
        if memory_types is None or MemoryType.SEMANTIC in memory_types:
            semantic_results = await self.vector.search(query_embedding, limit)
            results.extend(semantic_results)

        if memory_types is None or MemoryType.EPISODIC in memory_types:
            episodic_results = await self.graph.query_related(query)
            results.extend(episodic_results)

        # 按相关性排序
        return sorted(results, key=lambda x: x.relevance, reverse=True)[:limit]
```

## 7. 文件结构

```
backend/src/pdns/memory/
├── __init__.py
├── models.py              # 记忆数据模型
├── vector_store.py        # Qdrant向量存储
├── graph_store.py         # Neo4j图存储
├── relational_store.py    # SQLite关系存储
├── manager.py             # 统一记忆管理器
└── embedding.py           # 嵌入服务

data/
├── memory/
│   ├── qdrant/            # Qdrant本地存储
│   ├── neo4j/             # Neo4j数据
│   └── relational.db      # SQLite数据库
└── embeddings/            # 嵌入模型缓存
```

## 8. 使用示例

### 8.1 保存用户交互

```python
async def save_interaction(
    memory_manager: MemoryManager,
    user_id: str,
    message: str,
    response: str,
    emotion: str
):
    # 保存情景记忆
    await memory_manager.add_memory(
        content=f"用户发送: {message}\nAI回复: {response}",
        memory_type=MemoryType.EPISODIC,
        importance=0.7,
        metadata={"user_id": user_id, "emotion": emotion}
    )

    # 保存情感记忆
    await memory_manager.add_memory(
        content=f"用户情绪: {emotion}",
        memory_type=MemoryType.EMOTIONAL,
        importance=0.8,
        metadata={"user_id": user_id}
    )
```

### 8.2 检索相关记忆

```python
async def recall_relevant(
    memory_manager: MemoryManager,
    query: str,
    user_id: str
):
    # 检索相关记忆
    memories = await memory_manager.recall(
        query=query,
        limit=5
    )

    # 构建上下文
    context = "\n".join([
        f"[{m.memory_type.value}] {m.content}"
        for m in memories
    ])

    return context
```
